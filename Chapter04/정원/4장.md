# 레플리케이션과 그 밖의 컨트롤러: 관리되는 파드 배포

4장에서 다루는 내용
- 파드의 안정적인 유지
- 동일한 파드의 여러 인스턴스 실행
- 노드 장애 시 자동으로 파드 재스케줄링
- 파드의 수평 스케줄링
- 각 클러스터 노드에서 시스템 수준의 파드 실행
- 배치 잡 실행
- 잡을 주기적 또는 한 번만 실행하도록 스케줄링

쿠버네티스 환경의 안정적인 유지를 위해 직접 파드를 생성하는 일은 거의 없을 것이다. 대신 레플리케이션컨트롤러, 디플로이먼트와 같은 유형의 리소스를 생성해 파드를 생성하고 관리한다.<br>
4장에서는 컨테이너를 모니터링하고 실패하면 자동으로 다시 시작하는 방법을 배울 것이다.

## 파드를 안정적으로 유지하기
파드가 노드에 스케줄링되는 즉시, 해당 노드의 Kubelet은 파드의 컨테이너를 실행하고 파드가 존재하는 한 컨테이너가 계속 실행되도록 할 것이다. 컨테이너의 주 프로세스에 크래시가 발생하면 Kubelet이 컨테이너를 다시 시작한다.<br>
하지만 때때로 애플리케이션은 크래시 없이도 작동이 중단되기도 한다(OutOfMemory, 무한루프 등). 이런 경우 외부에서 상태를 체크해야 한다.

### 라이브니스 프로브 소개
k8s는 라이브니스 프로브를 통해 컨테이너가 살아 있는지 확인 한다. 파드의 스펙에 각 컨테이너의 라이브니스 프로브를 지정할 수 있다.
- 프로브는 지정한 IP, PORT에 HTTP GET요청을 날려본다. 오류 응답 코드가 돌아 오면 실패한것으로 간주해 컨테이너를 다시 시작한다.
- TCP 소켓 프로브는 지정된 포트에 TCP 연결을 시도 한다.
- Exec 프로브는 컨테이너 내 임의의 명령을 실행 한다.

### HTTP 기반 라이브니스 프로브 생성
```YAML
apiVersion: v1
kind: pod
metadata:
    name: kubia-liveness
spec:
    containers:
        - image: kubia-liveness
          name: kubia
          livenessProbe:
          httpGet:            // HTTP GET을 수행하는 라이브니스 프로브
            path: /
            port: 8080
```

### 동작중인 라이브니스 프로브 확인
```
kubectl get po kubia-liveness // 파드 생성 확인

kubectl describe po kubia-liveness // 컨테이너가 다시 시작된 이유를 확인 할 수 있다.
```

### 라이브니스 프로브의 추가 속성 설정
```
Liveness: http-get http://:8080/ delay=0s timeout=1s period=10s #failure=3
```
- delay : 컨테이너가 실행되고 x초 후부터 시작 한다.
- timeout : 컨테이너가 x초 안에 응답 해야 한다. 그렇지 않으면 프로브가 실패한 것으로 카운트된다.
- period : x초 주기로 상태를 확인 한다.
- failure : 프로브가 x번 연속 실패하면 컨테이너가 다시 시작된다. 

이런 추가적인 매개변수는 프로브를 정의할 때 지정할 수 있다.<br>

초기 지연을 설정하지 않으면 프로브는 컨테이너가 시작되자마자 프로브를 시작한다. 이 경우 대부분 애플리케이션이 요청을 받을 준비가 돼 있지 않기 때문에 프로브가 실패한다.
>> 팁 : 애플리케이션 시작 시간을 고려해서 초기 지연을 설정해야 한다는 점을 명심하자.

### 효과적인 라이브니스 프로브 생성
운영 환경에서 실행 중인 파드는 반드시 라이브니스 프로브를 정의해야 한다. <br><br>

**라이브니스 프로브가 확인해야 할 사항** <br>
더 나은 라이브니스 프로브를 위해 특정 URL 경로에 요청하도록 프로브를 구성해 애플리케이션 내에서 실행 중인 모든 주요 구성 요소가 살아 있는지 또는 응답이 없는지 확인하도록 구성할 수 있다.
>> 팁 : HTTP 엔드포인트에 인증이 필요하지 않은지 확인하라. 그렇지 않으면 프로브가 항상 실패해 컨테이너가 무한정으로 재시작된다.

<br>

**프로브를 가볍게 유지하기**<br>
라이브니스 프로브는 너무 많은 연산 리소스를 사용해서는 안 되며, 완료하는 데 너무 오래 걸리지 않아야 한다.

<br>

**프로브에 재시도 루프를 구현하지 마라**<br>
프로브에 자체적인 재시도 루프를 구현하는 것은 헛수고다.

<br>

## 레플리케이션컨트롤러 소개
레플리케이션컨트롤러는 쿠버네티스 리소스로서 파드가 항상 실행되도록 보장한다. 어떤 이유에서던 파드가 사라지면, 쉽게 말해 클러스터에서 노드가 사라지거나 노드에서 파드가 제거된 경우, 레플리케이션컨트롤러는 사라진 파드를 감지해 교체 파드를 생성한다.

### 레플리케이션컨트롤러의 동작
레플리케이션컨트롤러는 실행 중인 파드 목록을 지속적으로 모니터링하고, 특정 유형의 실제 파드 수가 의도하는 수와 일치하는지 항상 확인한다. 파드가 너무 적게 실행 중인 경우 파드 템플릿에서 새 복제본을 만든다. 너무 많은 파드가 실행 중이면 초과 복제본이 제거된다.

<br>

**컨트롤러 조정 루프 소개**<br>
//사진

<br>

**레플리케이션컨트롤러의 세 가지 요소 이해**<br>
- 레이블 셀럭터 : 레플리케이션컨트롤러의 범위에 있는 파드를 결정한다.
- 레플리카 수 : 실행할 파드의 의도하는 수를 지정한다.
- 파드 템플릿 : 새로운 파드 레플리카를 만들 때 사용된다.

>> 레이블 셀렉터와 파드 템플릿을 변경해도 기존 파드에는 영향을 미치지 않는다.

### 레플리케이션컨트롤러 생성
```YAML
apiVersion: v1
kind: ReplicationController
metadata:
  name: kubia
spec:
  replicas: 3
  selector:
    app: kubia
template:
  metadata:
    labels:
      app: kubia
  spec:
    containers:
    - name: kubia
      image: luska/kubia
      ports:
        -containerPort: 8080
```
 파일을 API서버에 게시하면, 쿠버네티스는 레이블 셀렉터 app=kubia와 일치하는 파드 인스턴스가 세 개를 유지하도록 하는 kubia라는 이름의 새로운 레플리케이션컨트롤러를 생성한다.


### 레플리케이션컨트롤러 작동 확인

**레플리케이션컨트롤러 정보 얻기**<br>
 ```
 kubectl get rc // 리플리케이션컨트롤러의 약어로 rc를 사용한다.

 kubectl describe rc kubia // describe 명령을 사용해 추가 정보를 볼 수 있다.
 ```

<br>

**컨트롤러가 새로운 파드를 생성한 원인 정확히 이해하기**<br>
컨트롤러가 새 교체 파드를 만들어 파드 삭제에 대응하는것은 엄밀히 말하면 삭제 그 자체에 대한 대응이 아니라 결과적인 상태에 대응하는 것이다.

<br>

**노드 장애 대응**<br>
노드에 장애가 나면 자동으로 해당 노드에 있던 애플리케이션이 다른 노드들로 마이그레이션 된다.

<br>

### 컨트롤러에서 파드를 제거하는 실제 사례
특정 파드에 어떤 작업을 하려는 경우 해당 파드를 레플리케이션컨트롤러의 범위에서 제거하면 작업이 훨씬 수월해진다.<br>
예를 들어 일정 시간이 지난 후 또는 특정 이벤트가 발생한 후에 파드가 제대로 동작하지 않는 버그가 있다고 가정해보자. 파드가 오작동한다는 것을 안다면 파드를 레플리케이션컨트롤러의 범위 밖으로 빼내 컨트롤러가 새 파드로 교체 하도록 한 다음, 파드를 디버그하거나 문제를 재연해볼 수 있다.

### 파드 템플릿 변경
템플릿을 변경하는것은 쿠키 커터를 변경하는것이다. 이미 완성된 쿠키에는 아무 영향을 주지 않는다.

### 수평 파드 스케일링
파드 수를 늘리거나 줄이는 것은 레플리케이션컨트롤러 리소스의 replicas 필드 값을 변경하기만 하면 된다.

### 레플리케이션컨트롤러 삭제
kubectl delete를 통해 레플리케이션컨트롤러를 삭제하면 파드도 삭제 된다. --cascade=false 옵션을 통해 파드는 삭제되지 않도록 할 수 있다.

## 레플리케이션컨트롤러 대신 레플리카셋 사용하기
레플리카셋은 차세대 레플리케이션컨트롤러이며, 레플리케이션컨트롤러를 완전히 대체할 것이다.

### 레플리케이션컨트롤러와 레플리카셋의 차이
레플리케이션컨트롤러는 특정 레이블을 갖는 파드만 매칭 시킬 수 있었지만 레플리카셋은 여러 레이블을 그룹으로 매치 할 수 있다.

### 레플리카셋 정의하기
```YAML
apiVersion: apps/v1beta2
kind: ReplicaSet
metadata:
  name: kubia
spec:
  replicas: 3
  selector:
    matchLabels: // 매치 레이블을 사용 한다.
      app: kubia
  template:
    metadata:
      labels:
        app: kubia
    spec:
      containers:
      - name: kubia
        image: luksa/kubia
```

### 레플리카셋 생성 및 검사
```
kubectl create 명령어로 YAML을 이용해 레플리카셋을 생성하라.

kubectl get rs
```
레플리케이션컨트롤러와 크게 다르지 않다.

### 레플리카셋의 더욱 표현적인 레이블 셀렉터 사용하기
matchExpressions 키워드로 표현식을 사용해 레이블을 선택 할 수 있다.

## 데몬셋을 사용해 각 노드에서 정확히 한 개의 파드 실행하기
클러스터의 모든 노드에, 노드당 하나의 파드만 실행되길 원하는 경우가 있을 수 있다. 시스템 수준의 작업을 수행하는 인프라 관련 파드가 이런 경우다. 예를 들면 모든 노드에서 로그 수집기와 리소스 모니터를 실행하려는 경우가 좋은 예이다.

### 데몬셋으로 모든 노드에 파드 실행하기
모든 클러스터 노드마다 파드를 하나만 실행하려면 데몬셋 오브젝트를 생성해야 한다. 데몬셋에 의해 생성되는 파드는 타깃 노드가 이미 지정돼 있고 쿠버네티스 스케줄러를 건너뛰는 것을 제외하면 레플리카셋과 매우 유사하다.<br>
데몬셋은 노드가 추가되면 새 파드 인스턴스를 새 노드에 배포한다.

### 데몬셋을 사용해 특정 노드에서만 파드를 실행하기
데몬셋 정의의 일부인 파드 템플릿에서 node-Selector 속성을 지정하면 된다.

## 완료 가능한 단일 태스크를 수행하는 파드 실행

### 잡 리소스 소개
쿠버네티스는 잡 리소스로 이런 기능을 지원하며, 잡은 파드의 컨테이너 내부에서 실행 중인 프로세스가 성공적으로 완료되면 컨테이너를 다시 시작하지 않는 파드를 실행할 수 있다.

### 잡 리소스 정의
```YAML
apiVersion: batch/v1
kind: Job
metadata:
  name: batch-job
spec:
  template:
    metadata:
      labels:
        app: batch-job
    spec:
      restartPolicy: OnFailure
      containers:
      - name: main
        image: luksa/batch-job
```

## 잡 부가 작업
- 순차적으로 잡 파드 실행하기
- 병렬로 잡 파드 실행하기
- 잡 스케일링
- 잡 파드가 완료되는데 걸리는 시간 제한하기
등의 작업이 가능 하다.

## 잡을 주기적으로 또는 한 번 실행되도록 스케줄링하기
크론 기능을 쿠버네티스에서도 지원 한다.

```YAML
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name:
spec:
  schedule: "0, 15, 30, 54 * * * *" // 이 잡은 매일, 매 시간 0, 15, 30, 45분에 실행 된다.
  jobTemplate:
    spec:
    ~~~
```

