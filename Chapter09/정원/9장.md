# 디플로이먼트: 선언적 애플리케이션 업데이트

9장에서 다루는 내용
- 파드를 최신 버전으로 교체
- 관리되는 파드 업데이트
- 디플로이먼트 리소스로 파드의 선언적 업데이트
- 롤링 업데이트 수행
- 잘못된 버전의 롤아웃 자동 차단
- 롤아웃 속도 제어
- 이전 버전으로 파드 되돌리기

이번장에서는 쿠버네티스 클러스터에서 실행되는 애플리케이션을 업데이트하는 방법과 쿠버네티스가 어떻게 무중단 업데이트를 할 수 있는지 설명 한다.

<br>

## 파드에서 실행 중인 애플리케이션 업데이트
파드를 업데이트하는 방법에는 두 가지가 있다.
- 기존 파드를 모두 삭제한 다음 새 파드를 시작 한다.
- 새로운 파드를 시작하고, 기동하면 기존 파드를 삭제한다. 새 파드를 모두 추가한 다음 한꺼번에 기존 파드를 삭제하거나 순차적으로 새 파드를 추가하고 기존 파드를 점진적으로 제거해 이 작업을 수행할 수 있다.

첫 번째의 단점은 일시적으로 애플리케이션 사용 불가, 두 번째의 단점은 두 버전의 애플리케이션이 동시에 존재하기 때문에 스키마나 데이터 수정이 어려움.

<br>

### 오래된 파드를 삭제하고 새 파드로 교체
레플리케이션 컨트롤러에서 파드 템플릿을 업데이트 한다.
[그림 9.2]

<br>

### 새 파드 기동과 이전 파드 삭제
다운타임이 발생하지 않고 한 번에 여러 버전의 애플리케이션이 실행하는 것을 지원하는 경우 이 방법을 사용 한다. 잠시동안 동시에 두 배의 파드가 실행되므로 더 많은 하드웨어 리소스가 필요하다. <br>
[그림 9.3]

**한 번에 이전 버전에서 새버전으로 전환**<br>
새 버전을 띄우고 서비스의 레이블 셀렉터를 변경해 전환 할 수 있다.

**롤링 업데이트 수행**<br>
단계별로 교체하는 롤링 업데이트를 수행할 수도 있다.

<br>

## 레플리케이션컨트롤러로 자동 롤링 업데이트 수행

### 애플리케이션의 초기 버전 실행
1. v1 버전의 애플리케이션 생성
2. 단일 YAML 파일을 사용한 애플리케이션 실행과 서비스 노출

### kubectl을 이용한 롤링 업데이트
1. v2 버전의 애플리케이션 생성 && 도커 허브에 이미지 푸시
2. kubectl rolling-update kubia-v1 kubia-v2 --image=luksa/kubia:v2

2 명령어를 수행하면 kubia-v2라는 새 레플리케이션컨트롤러가 즉시 만들어진다.<br>
기존 파드에 deployment라는 레이블을 만들어 버전을 구분 한다.

### kubectl rolling-update를 더 이상 사용하지 않는 이유
kubectl을 이용해서 업데이트를 하는것은 마스터 노드가 작업을 수행하는것이 아닌 클라이언트가 작업을 수행 하는 것이다. kubectl 업데이트 동안 네트워크 연결이 끊어지게 된다면 업데이트 프로세스 중간에 중단 될 위험이 있다.

## 애플리케이션을 선언적으로 업데이트하기 위한 디플로이먼트 사용하기
디플로이먼트는 lower-level 개념인 레플리케이션컨트롤러 또는 레플리카셋을 통해 수행하는 대신 애플리케이션을 배포하고 선언적으로 업데이트하기 위한 high-level의 리소스다.<br>
[그림 9.8]

<br>

### 디플로이먼트 생성
**디플로이먼트 매니페스트 생성**<br>
```YAML
apiVersion: apps/v1beta1
kind: Deployment
metadata:
    name: kubia
spec:
    replicas: 3
    template:
        meatadata:
            name: kubia
            labels:
                app: kubia
        spec:
            containers:
            - image: luksa/kubia:v1
              name: nodejs
```

kubectl create -f kubia-depoyment-v1.yaml --record 명령으로 디플로이먼트 생성

<br>

**디플로이먼트 롤아웃 상태 출력**<br>
kubectl rollout status deployment kubia
>> deployment kubia successfully rolled out

<br>

**디플로이먼트가 레플리카셋을 생성하는 방법과 레플리카셋이 파드를 생성하는 방식 이해**<br>
파드 이름이 kubia-1506449474-otnnh 처럼 생성 된다. 가운데 숫자값은 디플로이먼트와 파드 템플릿의 해시값을 의미하며 레플리카셋이 이러한 파드를 관리함을 뜻한다. 레플리카셋의 이름에도 해당 파드 템플릿의 해시값이 포함된다.

### 디플로이먼트 업데이트
기존의 kubectl rolling-update는 쿠버네티스에 업데이트를 수행하도록 명시적으로 지시해야 했다. 심지어 새로운 레플리케이션컨트롤러의 이름을 지정해야 했다. 그리고 이 프로세스동안 터미널을 열어두고 kubectl이 롤링 업데이트를 완료할 때까지 기다려야 했다. 이제 디플로이먼트를 사용해 리소스에 정의된 파드 템플릿을 통해 배포 되도록 할 수 있다.

**사용가능한 디플로이먼트 전략**<br>
기본은 RollingUpdate라는 전략이다. 대안으로 Recreate전략이 있는데, 한 번에 기존 모든 파드를 삭제한 뒤 새로운 파드를 만든다. <br>
RollingUpdate 전략은 이전 파드를 하나씩 제거하고 동시에 새 파드를 추가해 전체 프로세스에서 애플리케이션을 계속 사용할 수 있도록 하고 서비스 다운 타임이 없도록 한다. 애플리케이션에서 이전 버전과 새 버전을 동시에 실행할 수 있는 경우메나 이 전략을 사용해야 한다.

**롤링 업데이트 시작**<br>
kubectl set image deployment kubia nodejs=luksa/kubia:v2 <br>
위 명령어로 디플로이먼트를 수정 할 수 있다.<br>

**디플로이먼트의 놀라옴**<br>
디플로이먼트 리소스에서 파드 템플릿을 변경하는 것만으로 애플리케이션을 최신 버전으로 업데이트했다!
업데이트하는 동안 디플로이먼트 영역에서 발생한 이벤트는 kubectl rolling-update를 수행하는 동안 발생한 이벤트와 유사하다. 추가 레플리카셋이 생성됐고, 그 후 천천히 스케일 업했으며, 이전 레플리카셋의 크기를 0으로 스케일 다운했다.

<br>

### 디플로이먼트 롤백
1. 애플리케이션 버전 3 만들기
2. 버전 3 배포하기
3. 롤아웃 되돌리기
    - kubectl rollout undo deployment kubia 명령으로 수동으로 되돌릴 수 있다.
    - kubectl rollout history deployment kubia 명령어로 롤아웃 이력을 표시 할 수 있다.
    - kubectl rollout undo deployment kubia --to-revision=1 명령어로 특정 개정으로 롤백 할 수 있다.

<br>

### 롤아웃 속도 제어
maxSurge와 maxUnavailable속성을 설정하여 제어 할 수 있다. <br>
- maxSurge : 배포 중 최대 maxSurge % 만큼의 파드가 더 존재 할 수 있다.
- maxUnavailable : 배포 중 사용가능한 파드가 maxUnavailable % 이하로는 떨어지지 않아야 한다.

**롤아웃 프로세스 일시 중지**<br>
kubectl rollout pause deployment kubia 명령어로 일시 중지 가능

**롤아웃 재개**<br>
kubectl rollout resume deployment kubia 명령어로 재개 가능

<br>

### 잘몬된 버전의 롤아웃 방지
**minReadySeconds의 적용 가능성 이해**<br>
minReadySeconds 속성은 파드를 사용 가능한 것으로 취급하기 전에 새로 만든 파드를 준비할 시간을 지정한다. 모든 파드의 레디니스 프로브가 성공하면 파드가 준비 된다. minReadySeconds가 지나기 전에 새 파드가 제대로 작동하지 않고 레디니스 프로브가 실패하기 시작하면 새 버전의 롤아웃이 효과적으로 차단된다.

**레디니스 프로브가 잘못된 버전으로 롤아웃되는 것을 방지하는법**<br>
새 파드가 시작되자마자 레디니스 프로브가 매초마다 시작된다. HTTP 상태 코드 500을 반환하면 레디니스 프로브가 실패하기 시작 한다. 결과적으로 파드는 서비스의 엔드포인트에서 제거 된다.

**롤아웃 데드라인 설정**<br>
기본적으로 롤아웃이 10분 진행되지 않으면 실패한것으로 간주 된다. progressDeadlineSeconds 속성으로 설정할 수 있다.