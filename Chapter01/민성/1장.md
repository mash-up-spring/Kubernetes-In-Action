# 1.1 쿠버네티스와 같은 시스템이 필요한 이유

### 1.1.1 모놀리스 애플리케이션에서 마이크로서비스로 전환

**모놀리스 애플리케이션**

1. 모든 것이 서로 강하게 결합
2. 전체가 하나의 운영체제 프로세스로 실행
    - 하나의 개체로 개발, 배포, 관리
    - 애플리케이션의 한 부분을 변경하더라도 전체 애플라케이션을 재배포
3. 시스템 복잡성 증가하고 품질이 저하
4. scale out(수평 확장)하기 어려운 구조

**마이크로서비스 애플리케이션**

1. 독립적으로 배포할 수 있는 작은 구성 요소로 분할
2. 특정 개발 언어에 종속적이지 않다.
3. 개별적으로 개발, 배포 가능

**마이크로서비스 확장**

- 리소스가 더 필요한 서비스만 별도로 확장이 가능하다.
    - 다른 서비스에 영향이 없다.
- 수평/수직 확장 용이

**마이크로서비스 배포**

- 구성 요소가 많아지면 배포 조합의 수뿐만 아니라 구성 요소 간의 상호 종속성 수가 훨씬 더 많아지므로 배포 관련 결정이 점점 더 어려워진다.
- 배포할 때 전체가 하나의 시스템처럼 동작할 수 있도록 제대로 구성되어야 한다.
- 여러 프로세스와 시스템에 분산돼 있기 때문에 실행 호출을 디버그하고 추적하기 어렵다.
    - Zipkin과 같은 분산 추적 시스템으로 해결

**환경 요구 사항의 다양성**

마이크로서비스에서는 독립적으로 배포될 뿐만 아니라 독립적인 방식으로 개발된다.

- 동일한 호스트에 배포해야 하는 구성 요소 수가 많을수록 모든 요구 사항을 충족시키려 모든 종속성을 관리하기가 더 어려워진다.

### 1.1.2 애플리케이션에 일관된 환경 제공

개발과 프로덕션 환경 사이에 큰 차이가 있을 경우 생길 수 있는 문제를 줄이기 위해 동일한 환경에서 실행되는 것이 이상적이다.

### 1.1.3 지속적인 배포로 전환: 데브옵스와 노옵스

데브옵스

- 개발자, 품질 보증, 운영 팀이 전체 프로세스에서 협업해야 한다는 의미
- 개발자가 프로덕션 환경에 관여할 수록 사용자가 무엇을 필요로 하고 무엇이 문제 인지 더 잘 이해할 수 있다.

노옵스

- 자동화로 운영 팀의 손이 거의 필요 없는 환경

→ 쿠버네티스를 사용하면 이 모든 것을 해결할 수 있다.

# 1.2 컨테이너 기술 소개

## 1.2.1 컨테이너 이해

### 리눅스 컨테이너 기술로 구성 요소 격리

- 리눅스 컨테이너 기술은 동일한 호스트 시스템에서 여러개의 서비스를 실행할수 있으며 동시에 서로 다른 환경을 만들어줄 뿐만 아니라 가상머신과 유사하게 서로 격리하지만 오버헤드가 훨씬 적다.
- 컨테이너에서 실행되는 프로세스는 호스트 운영체제 내에서 실행된다.

    (가상머신은 프로세스가 별도의 운영체제에서 실행된다.)

### 컨테이너와 가상머신 비교

컨테이너는 가상머신과 비교하면 훨씬 더 가볍다.

- 동일한 하드웨어에서 더 많은 수의 소프트웨어 구성 요소를 실행할 수 있다.

가상머신은 구성 요소 프로세스뿐만 아니라 시스템 프로세스를 실행해야 하기 때문에 컴퓨팅 리소스가 필요하다.

- 반면 컨테이너는 호스트 OS에서 실행되는 하나의 격리된 프로세스에 지나지 않으며, 애플리케이션이 소비하는 리소스만 소비하고 추가 프로세스의 오버헤드는 없다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83882529-24bd-4e32-bc40-33e8d40ef825/Untitled.png)

- 가상머신은 자체 리눅스 커널을 실행해 완전한 격리를 제공하는 데 반해 컨테이너는 모두 동일한 커널을 호출함으로 보안 위험이 발생할 수 있다는 것이다.

### 컨테이너 격리를 가능하게 하는 메커니즘 소개

1. 리눅스 네임스페이스
    - 각 프로세스가 시스템(파일, 프로세스, 네트워크 인터페이스, 호스트 이름 등)에 대한 독립된 뷰만 볼 수 있도록 한다.
2. 리눅스 컨트롤 그룹
    - 프로세스가 사용할 수 있는 리소스(CPU, 메모리, 네트워크 대역폭 등)의 양을 제한한다.

### 리눅스 네임스페이스로 프로세스 격리

- 리눅스 시스템은 초기 구동 시 하나의 네임스페이스가 있다.
    - 마운트, 프로세스 ID, 네트워크, 프로세스 간 통신, 호스트와 도메인 이름, 사용자 ID
- 프로세스를 실행할 때 해당 네임스페이스 중 하나에서 프로세스를 실행한다.
    - 프로세스는 동일한 네임스페이스 내에 있는 리소스만 볼 수 있다.
- 프로세스는 여러 네임스페이스에 속할 수 있다.

이를 통해서 네임스페이스는 특정 리소스 그룹을 격리하는데 사용 된다.

### 프로세스의 가용 리소스 제한

프로세스는 설정된 양 이상의 CPU, 메모리, 네트워크 대역폭 등을 사용할 수 없다.

## 1.2.2 도커 컨테이너 플랫폼 소개

도커로 패키징된 애플리케이션을 실행하면 함께 제공된 파일시스템 내용을 정확하게 볼 수 있다.

### 도커 개념 이해

도커는 애플리케이션을 패키징, 배포, 실행하기 위한 플랫폼이다.

- 애플리케이션에 필요한 몇 가지 라이브러리나 운영체제의 파일시스템에 설치되는 모든 파일을 포함시킬 수 있다.
- 도커를 사용하면 이 패키지를 중앙 저장소로 전송할 수 있으며, 도커를 실행하는 모든 컴퓨터에 전송할 수 있다.

**도커의 주요개념**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad5cef23-5fe6-4c13-aa14-837f15983b47/Untitled.png)

1. 이미지
    - 애플리케이션과 해당 환경을 패키지화한 것이다.
    - 애플리케이션에서 사용할 수 있는 파일시스템과 이미지가 실행될 때 실행돼야 하는 실행파일 경로와 같은 메타 데이터가 포함돼 있다.
2. 레지스트리
    - 도커 이미지를 저장하고 다른 사람이나 컴퓨터 간에 해당 이미지를 쉽게 공유할 수 있는 저장소다.
    - push/pull을 통해 공유가능
3. 컨테이너
    - 도커 기반 컨테이너 이미지에서 생성된 일반적인 리눅스 컨테이너다.

### 이미지 레이어의 이해

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/278d5cf7-92b4-4635-8440-50df5b186ce7/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/278d5cf7-92b4-4635-8440-50df5b186ce7/Untitled.png)

모든 도커 이미지는 다른 이미지 위에 빌드되며 두 개의 다른 이미지는 기본 이미지로 동일한 부모 이미지를 사용할 수 있으므로 다른 이미지에는 정확히 동일한 레이어가 포함될 수 있다.

→ 그렇기에 이미 전송한 레이어는 다시 전송할 필요가 없어져 네트워크로 이미지를 배포하는 속도가 빨라진다.

### 컨테이너 이미지의 제한적인 이식성의 이해

컨테이너화된 애플리케이션이 특정 커널 버전이 필요하다면 모든 시스템에서 작동하지 않을 수 있다.

## 1.2.3 도커의 대안으로 rkt 소개

도커 자체가 프로세스 격리를 제공하지 않는다. 컨테이너의 격리는 리눅스 네임스페이스와 cgroup과 같은 커널 기능으로 리눅스 커널 수준에서 수행된다.

도커와 마찬가지로 rkt도 컨테이너를 실행하기 위한 플랫폼이다. 이를 설명하는 이유는 쿠버네티스가 도커 기반 컨테이너만을 위해 특별히 만들어진 컨테이너 오케스트레이션 시스템이라고 생각하지 않도록하기 위해서이다.

# 1.3 쿠버네티스 소개

## 1.3.1 쿠버네티스의 기원

구글에서 보그, 오메가, 기타 내부 구글 시스템으로 얻은 경험을 기반으로 오픈소스 시스템인 쿠버네티스를 출시했다.

## 1.3.2 넓은 시각으로 쿠버네티스 바라보기

쿠버네티스는 컨테이너화된 애플리케이션을 쉽게배포하고 관리할수 있게 해주는 소프트웨어 시스템이다.

즉, 클러스터에 노드 수에 상관없이 쿠버네티스에 애플리케이션을 배포하는 것은 항상 동일하다.

### 쿠버네티스 핵심 이해

![스크린샷 2021-08-17 오후 4.44.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77ba703e-ad4f-40f3-82bd-982bfc6eec47/스크린샷_2021-08-17_오후_4.44.25.png)

- 시스템은 마스터 노드와 여러 워커 노드로 구성된다.
- 개발자는 특정 애플리케이션이 함께 실행되도록 지정할 수도 있으며 쿠버네티스는 여러 애플리케이션을 동일한 워커 노드에 배포한다.
- 다른 애플리케이션은 클러스터에 걸쳐서 분산되지만 배포된 위치에 상관없이 동일한 방식으로 서로 통신할 수 있다.

### 개발자가 애플리케이션 핵심 기능에 집중할 수 있도록 지원

쿠버네티스는 클러스터의 운영체제로 생각할 수 있다.

- 개발자가 특정 인프라 관련 서비스를 애플리케이션에 구현하지 않아도 된다.
    - 대신 쿠버네티스에 의존해 이런 서비스(디스커버리, 스케일링, 로드밸런싱, 자가 치유, 리더 선출 등)를 제공한다.

### 운영 팀이 효과적으로 리소스를 활용할 수 있도록 지원

애플리케이션은 어떤 노드에서 실행되든 상관이 없기 때문에 쿠버네티스는 언제든지 애플리케이션을 재배치하고 애플리케이션을 조합함으로써 리소스를 수동 스케줄링보다 훨씬 더 잘 활용할 수 있다.

## 1.3.3 쿠버네티스 클러스터 아키텍처 이해

### 하드웨어 수준에서 쿠버네티스

![스크린샷 2021-08-17 오후 5.28.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf3c67ac-9e3e-45ea-ae99-d081d07f1bd2/스크린샷_2021-08-17_오후_5.28.20.png)

- **마스터 노드**

    전체 쿠버네티스 시스템을 제어하고 관리하는 쿠버네티스 컨트롤 플레인을 실행한다.

- **워커 노드**

    실제 배포되는 컨테이너 애플리케이션을 실행한다.

### 컨트롤 플레인

컨트롤 플레인은 클러스터를 제어하고 작동시킨다. 하나의 마스터 노드에서 실행하거나 여러 노드로 분할되고 복제돼 고가용성을 보장할 수 있는 여러 구성 요소로 구성된다.

- 쿠버네티스 **API 서버**는 사용자, 컨트롤 플레인 구성 요소와 통신한다.
- **스케줄러**는 애플리케이션의 배포를 담당한다

    (애플리케이션의 배포 가능한 각 구성 요소를 워크 노드에 할당)

- **컨트롤러 매니저**는 구성 요소 복제본, 워크 노드 추적, 노드 장애 처리 등과 같은 클러스터단의 기능을 수행한다.
- **Etcd**는 클러스터 구성을 지속적으로 저장하는 신뢰할 수 있는 분산 데이터 저장소이다.

### 노드

워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템이다.

- 컨테이너를 실행하는 도커,rkt 또는 다른 컨테이너 런타임
- API 서버와 통신하고 노드의 컨테이너를 관리하는 Kubelet
- 애플리케이션 구성 요소 간에 네트워크 트래픽을 로드밸런싱하는 쿠버네티스 서비스 프록시(Kube-proxy)

## 1.3.4 쿠버네티스에서 애플리케이션 실행

쿠버네티스에서 애플리케이션을 실행하려면 먼저 애플리케이션을 하나 이상의 컨테이너 이미지로 패키징하고 해당 미지를 이미지 레지스트리로 푸시한 다음 쿠버네티스 API 서버에 애플리케이션 디스크립션을 게시해야 한다.

- 디스크립션에는 컨테이너 이미지, 애플리케이션 구성 요소가 포함된 이미지, 해당 구성 요소가 서로 통신하는 방법, 동일 서버에 함께 배치돼야 하는 구성요소와 같은 정보가 포함된다.
- 또한 내부 또는 외부 클라이언트에 서비스를 제공하는 구성 요소와 하나의 IP 주소로 노출해 다른 구성 요소에서 검색 가능하게 해야 하는 구성 요소가 포함된다.

### 디스크립션으로 컨테이너를 실행하는 방법 이해

![스크린샷 2021-08-17 오후 6.51.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/51d8fe84-dc93-4667-89d1-fc2409f1580b/스크린샷_2021-08-17_오후_6.51.45.png)

- API 서버가 애플리케이션 디스크립션을 처리할 때 스케줄러는 각 컨테이너에 필요한 리소스를 계산하고 해당 시점에 각 노드에 할당되지 않은 리소스를 기반으로 사용 가능한 워커 노드에 지정된 컨테이너를 할당한다.
- 이후 해당 노드의 kubelt은 컨테이너 런타임(docker)에 필요한 컨테이너 이미지를 가져와 컨테이너를 실행하도록 지시한다.

### 실행된 컨테이너 유지

애플리케이션이 실행되면 쿠버네티스는 애플리케이션의 배포 상태가 사용자가 제공한 디스크립션과 일치하는지 지속적으로 확인한다.

- 만약 인스턴스가 제대로 작동하지 않으면 쿠버네티스가 자동으로 다시 시작한다.
- 마찬가지로 워커 노드 전체가 종료되거나 엑세스할 수 없게 되면 쿠버네티스는 이 노드에서 실행 중인 모든 컨테이너의 노드를 새로 스케줄링하고, 새로 선택한 노드에서 실행한다.

### 복제본 수 스케일링

애플리케이션이 실행되는 동안 복제본 수를 늘릴지 줄일지 결정할 수 있으며, 쿠버네티스는 추가 복제본을 기동하거나 초과 복제본을 정지시킬 것이다.

- 최적의 복제본 수를 쿠버네티스에 맡길 수 있다.

### 이동한 애플리케이션에 접근하기

컨테이너를 클러스터 안에서 이동시킬 수도 있다.

- 쿠버네티스에 동일한 서비스를 제공하는 컨테이너를 알려주면 쿠버네티스는 하나의 고정 IP 주소로 모든 컨테이너를 노출하고 해당 주소를 클러스터에서 실행 중인 모든 애플리케이션에 노출한다.
    - 환경변수로 제공되지만 DNS로 서비스 IP를 조회 가능하다.
    - kube-proxy는 서비스를 제공하는 모든 컨테이너에서 서비스 연결이 로드밸런싱되도록 한다.
    - 서비스의 IP는 일정하게 유지된다.
        - 컨테이너는 다른 노드로 옮겨져 재시작하면 새 IP 할당.

### 쿠버네티스 사용의 장점

모든 서버에 쿠버네티스를 설치할 경우 운영 팀이 더 이상 애플리케이션 배포를 처리할 필요가 없다.

### 애플리케이션 배포의 단순화

쿠버네티스는 모든 워커 노드를 하나의 배포 플랫폼으로 제공하기 때문에 애플리케이션 개발자는 자체적으로 애플리케이션 배포를 시작할 수 있으며 클러스터를 구성하는 서버에 관해 알 필요가 없다.

### 하드웨어 활용도 높이기

컨테이너를 사용하고 애플리케이션을 클러스터의 특정 노드로 지정하지 않으면 언제든지 다른 애플리케이션 구성 요소를 혼합해 클러스터 노드에 배치할 수 있다. 즉, 노드의 하드웨어 리소스를 최대한 활용할 수 있다.

### 상태 확인과 자가 치유

쿠버네티스는 모니터링하다가 노드 장애 발생 시 자동으로 애플리케이션을 다른 노드로 스케줄링한다.

### 오토스케일링

쿠버네티스는 각 애플리케이션에서 사용하는 리소스를 모니터링하고 각 애플리케이션의 실행 중인 인스턴스 수를 계속 조정하도록 지실할 수 있다.

- 클라우드 인프라에서 쿠버네티스가 실행중인 경우 해당 업체의 API를 통해 쉽게 스케일링할 수 있다.

### 애플리케이션 개발 단순화

- 개발과 프로덕션 환경이 모두 동일한 환경에서 실행된다.
- 개발자가 일반적으로 구현해야 하는 기능을 구현할 필요가 없어진다.
    - 클러스터된 애플리케이션에서 서비스나 피어를 검색하는 기능
    - 리더 선출
- 애플리케이션을 출시할 때 쿠버네티스가 새로운 버전이 잘못됐는지 자동으로 감지하고 즉시 롤아웃을 중단한다.

# 1.4 요약

- 모놀리스 애플리케이션은 구축하기 쉽지만 확장이 어렵고 유지 보수가 비교적 힘들다

    → 이에 마이크로서비스 기반 애플리케이션 아키텍처가 등장, 그러나 하나의 시스템으로 작동하도록 배포하고 구상하기가 어렵다.

- 리눅스 컨테이너는 가상머신과 동일한 이점을 제공하지만 훨씬 더 가볍고 하드웨어 활용도를 높일 수 있다.
- 도커는 OS 환경과 함께 컨테이너화된 애플리케이션을 좀 더 쉽고 빠르게 프로비저닝할 수 있도록 지원해 기존 리눅스 컨테이너 기술을 개선했다.
- 쿠버네티스는 전체 데이터 센터를 애플리케이션 실행을 위한 컴퓨팅 리소스로 제공한다.

    → 개발자는 시스템 관리자의 도움 없이도 쿠버네티스로 애플리케이션 배포 가능

    → 시스템 관리자는 쿠버네티스가 고장 난 노드를 자동으로 처리하도록 하여 운영이 수월해짐