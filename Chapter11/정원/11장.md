# 쿠버네티스 내부 이해

11장에서 다루는 내용

- 쿠버네티스 클러스터 구성 요소
- 각 구성 요소의 기능과 동작 방법
- 디플로이먼트 오브젝트를 생성해 파드를 실행하는 방법
- 실행 중인 파드에 관하여
- 파드 간의 네트워크 동작 방식
- 쿠버네티스 서비스의 동작 방식
- 고가용성 실현 방법

## 아키텍처 이해

쿠버네티스는 두 부분으로 나눠진다.

- 쿠버네티스 컨트롤 플레인
- (워커) 노드

**컨트롤 플레인 구성 요소**<br>

- etcd 분산 저장 스토리지
- API 서버
- 스케줄러
- 컨트롤 매니저

**워커 노드에서 실행하는 구성 요소**<br>

- Kubelet
- 쿠버네티스 서비스 프록시
- 컨테이너 런타임

**애드온 구성 요소**<br>

- 쿠버네티스 DNS서버
- 대시보드
- 인그레스 컨트롤러
- 힙스터
- 컨테이너 네트워크 인터페이스 플러그인

### 쿠버네티스 구성 요소의 분산 특성

- 쿠버네티스 시스템 구성 요소는 오직 API 서버하고만 통신한다. API 서버는 etcd와 통신하는 유일한 구성 요소다.
- 워커 노드의 구성 요소는 모두 동일한 노드에서 실행돼야 하지만 컨트롤 플레인의 구성 요소는 여러 서버에 걸쳐 실행될 수 있다.
- kube-proxy와 같은 컨트롤 플레인 구성 요소는 시스템에 직접 배포하거나 파드로 실행 할 수 있다. Kubelet은 항상 일반 시스템 구성 요소로 실행되는 유일한 구성 요소이며, Kubelet이 다른 구성 요소를 파드로 실행한다.

### 쿠버네티스가 etcd를 사용하는 방법

이 책에서 생성한 모든 오브젝트(파드, RC, 서비스 등)는 API 서버가 다시 시작되거나 실패하더라도 유지하기 위해 매니페스트가 영구적으로 저장될 필요가 있다. 이를 위해 쿠버네티스는 빠르고, 분산해서 저장되며 일관된 키-값 저장소를 제공하는 etcd를 사용한다.<br>
쿠버네티스 API서버만이 etcd와 직접적으로 통신하는 유일한 구성 요소다. 이로써 강력한 낙관적 잠금 시스템뿐만 아니라 유효성을 검사하는 등의 이점을 얻을 수 있다.

- 쿠버네티스는 모든 데이터를 /registry 아래애 저장 한다. etcdctl ls /registry 명령어를 통해 확인 가능.
- 저장된 오브젝트의 일관성과 유효성 보장
- 클러스터링된 etcd의 일관성 보장
- etcd의 인스턴스는 하나의 인스턴스에 장애가 나더라도 과반을 보장 하기 위해 홀수로 유지한다.

### API 서버의 기능

쿠버네티스 API 서버는 다른 모든 구성 요소와 kubectl 같은 클라이언트에서 사용하는 중심 구성 요소다. 클러스터 상태를 조회하고 변경하기 위해 RESTful API로 CRUD 인터페이스를 제공한다. 상태는 etcd안에 저장한다.

1. 인증 플러그인으로 클라이언트 인증
2. 인가 플러그인을 통한 클라이언트 인가
3. 어드미션 컨트롤 플러그인으로 요청된 리소스 확인과 수정. (AlwaysPullImages, ServiceAccount, NamespaceLifecycle, ResourceQuota)
4. 리소스 유혀성 확인 및 영구 저장

### API 서버가 리소스 변경을 클라이언트에 통보하는 방법 이해

API서버가 컨트롤러에 통보하는것이 아니다. 단지 배포된 리소스의 변경 사항을 관찰할 수 있도록 하면 된다.<br>
[그림 11.4] 참고

### 스케줄러 이해

**기본 스케줄링 알고리즘 이해**<br>

- 모든 노드 중에서 파드를 스케줄링할 수 있는 노드 목록을 필터링한다.
- 수용 가능한 노드의 우선순위를 정하고 점수가 높은 노드를 선택한다. 만약 여러 노드가 같은 최상위 점수를 가지고 있다면, 파드가 모든 노드에 고르게 배포되도록 라운드-로빈을 사용한다.

**수용 가능한 노드 찾기**<br>
스케줄러는 미리 설정된 조건 함수 목록을 각 노드에 전달 한다.

- 노드가 하드웨어 리소스에 대한 파드 요청을 충족시킬 수 있는가
- 노드에 리소스가 부족한가
- 노드 셀렉터와 일치하는 레이블을 가지고 있는가
- etc...

### 컨트롤러 매니저에서 실행되는 컨트롤러 소개

컨트롤러는 다양한 작업을 수행하지만 모두 API 서버에서 리소스가 변경되는 것을 감시하고 각 변경 작업을 수행한다. 대부분 이러한 작업은 다른 리소스 생성, 감시 중인 리소스 자체를 갱신하는 것이 포함된다.

- 레플리케이션 매니저 : 레플리케이션컨트롤러 리소스를 활성화하는 컨트롤러
- 레플리카셋, 데몬셋, 잡 컨트롤러
- 디플로이먼트 컨트롤러
- 스테이트풀셋 컨트롤러
- 노드 컨트롤러
- 서비스 컨트롤러
- 엔드포인트 컨트롤러
- 네임스페이스 컨트롤러
- 퍼시스턴트볼륨 컨트롤러

### kubelet이 하는 일

간단히 말해서 Kubelet은 워커 노드에서 실행하는 모든 것을 담당하는 구성 요소다. 첫 번째 작업은 kubelet이 실행 중인 노드를 노드 리소스로 만들어 API 서버에 등록하는 것이다.
그 다음 API 서버를 지속적으로 모니터링해 해당 노드에 파드가 스케줄링되면, 파드의 컨테이너를 시작한다.<br>
kubelet은 실행 중인 컨테이너를 계속 모니터링하면서 상태, 이벤트, 리소스 사용량을 API서버에 보고한다.

### 쿠버네티스 서비스 프록시의 역할

kubelet 외에도, 모든 워커 노드는 클라이언트가 쿠버네티스 API로 정의한 서비스에 연결할 수 있도록 해주는 kube-proxy도 같이 실행한다. kube-proxy는 서비스의 IP와 포트로 들어온 접속을 서비스를 지원하는 파드 중 하나와 연결시켜준다. 서비스가 둘 이상의 파드에서 지원되는 경우 프록시는 파드 간에 로드밸런싱을 수행한다.

### 쿠버네티스 애드온 소개

쿠버네티스 서비스의 DNS 조회, 여러 HTTP 서비스를 단일 외부 IP주소로 노출하는 기능, 쿠버네티스 웹 대시보드와 같은 것들이 있다.

- 애드온 배포 방식 : YAML 매니페스트를 API 서버에 게시해 파드로 배포된다.
- DNS 서버 동작 방식 : 클러스터의 모든 파드는 기본적으로 클러스터의 내부 DNS 서버를 사용하도록 설정돼 있다. 헤드리스 파드인 경우 패당 파드의 IP 주소를 조회할 수 있다.
- 인그레스 컨트롤러 동작 방식 : 리버스 프록시 서버를 실행하고 클러스터에 정의된 인그레스, 서비스, 엔드포인트 리소스 설정을 유지한다. 컨트롤러는 이러한 리소스를 감시하고 변경이 일어날 때마다 프록시 서버 설정을 변경한다.

## 컨트롤러가 협업하는 방법

### 이벤트 체인

디플로이먼트 매니페스트를 가진 YAML 파일을 준비해 kubectl 명령으로 이를 쿠버네티스에 게시한다고 가정하자. kubectl은 매니페스트를 HTTP POST 요청으로 쿠버네티스 API 서버에 전송한다. API 서버는 디플로이먼트 정의를 검증하고 etcd에 저장한 후에 kubectl에 응답을 돌려준다. [그림 11.12] 같이 연계된 이벤트가 발생하기 시작한다.

- 디플로이먼트 리소스생성
- 감시를 통한 통보
- 레플리카셋 생성
- 통보
- 파드 생성
- 감시를 통한 통보
- 파드를 노드에 할당

### 클러스터 이벤트 관찰

컨트롤 플레인 구성 요소와 kubelet은 이러한 작업을 수행할 때 API 서버로 이벤트를 발송한다. 다른 쿠버네티스 리소스와 마찬가지로 이벤트 리소스를 만들어 이를 수행한다.<br>
이미 kubectl describe 명령을 사용할 때마다 특정 리소스와 관련된 이벤트를 봤지만, kubectl get events 명령을 이용해 이벤트를 직접 검색할 수도 있다.

## 실행 중인 파드에 관한 이해

파드를 실행 하면 네임스페이스를 모두 보유하는게 유일한 목적인 인프라스트럭처 컨테이너인 퍼즈 컨테이너가 실행 된다. 실행된 여러 파드들은 파드 인프라스트럭처 컨테이너의 네임스페이스를 사용 한다.

## 파드 간 네트워킹

쿠버네티스는 특정한 네트워크 기술을 사용할 것을 요구하지는 않지만, 파드가 동일한 워커 노드에서 실행 중인지 여부와 관계없이 파드끼리 서로 통신할 수 있어야 한다. 파드가 통신하는 데 사용하는 네트워크는 파드가 보는 자신의 IP 주소가 모든 다른 파드에서 해당 파드 주소를 찾을 때 정확히 동일한 IP 주소로 보이도록 해야 한다.

### kube-proxy 소개

서비스와 관련된 모든 것은 각 노드에서 동작하는 kube-proxy 프로세스에 의해 처리된다. 초기에는 kube-proxy가 실제 프록시로서 연결을 기다리다가, 들어온 연결을 위해 해당 파드로 가는 새로운 연결을 생성했다. 이것을 userspace 프록시 모드라고 한다. 나중에는 성능이 더 우수한 iptables 프록시 모드가 이를 대체했다.

## 고가용성 클러스터 실행

### 애플리케이션 가용성 높이기

- 가동 중단 시간을 줄이기 위한 다중 인스턴스 실행
- 수평 스케일링이 불가능한 애플리케이션을 위한 리더 선출 메커니즘 사용

### 쿠버네티스 컨트롤 플레인 구성 요소의 가용성 향상

- etcd 클러스터 실행
- 여러 API 서버 인스턴스 실행
- 컨트롤러와 스케줄러의 고가용성 확보
